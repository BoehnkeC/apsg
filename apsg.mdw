---
title: Structural geology module for Python
author: Ondrej Lexa
email: <lexa.ondrej@gmail.com>
institute: ÚPSG, Charles University
---

Download and install APSG module
--------------------------------

APSG is distributed as a single file with no traditional python install
implemented yet. For now, download `apsg.py` file and save it to
working directory or to any folder on `PYTHONPATH`.

First steps with APSG module
============================

APSG defines several new python classes to easily manage, analyze
and visualize orientational structural geology data. Base class `Vec3`
is derived from `numpy.array` class and affers several new method
which will be explained on following examples.

Import APSG module
------------------

APSG module could be imported either into own namespace or into
active one for easier interactive work:

<<term = True>>=
from apsg import *
@

Basic operations with vectors
----------------------------

Instance of vector object `Vec3` could be created from any iterable
object as list, tuple or array:

<<term = True>>=
u = Vec3([1, -2, 3])
v = Vec3([-2, 1, 1])
@

For common vector operation we can use standard mathematical operators
or special methods using dot notation:

<<term = True>>=
u+v
u-v
3*u-2*v
@

Its magnitude or length is most commonly defined as its Euclidean norm
and could be calculated using `abs`:

<<term = True>>=
abs(v)
abs(u)
abs(2*u)
@

For *dot product* we can use multiplification operator `*`
or `dot` method:

<<term = True>>=
u*v
u.dot(v)
@

For *cross product* we can use operator `**` or method `cross`:

<<term = True>>=
u**v
u.cross(v)
@

To project vector `u` onto vector `v` we can use
method `proj`:

<<term = True>>=
u.proj(v)
@

To find angle (in degrees) between to vectors we use method `angle`:

<<term = True>>=
u.angle(v)
@

Method `rotate` provide possibility to rotate vector around
another vector. For example, to rotate vector `u` around
vector `v` for 45°:

<<term = True>>=
u.rotate(v,45)
@

Classes Lin, Fol and Pole
=========================

To work with orientational data in structural geology, APSG
provide two classes derived from `Vec3` class. There is `Fol`
class to represent planar features by planes and `Lin` class
to represent linear feature by lines. Both classes provide all
`Vec3` methods, but they differ in way how instance is created
and how some operations are calculated, as structural geology
data are commonly axial in nature. The special class `Pole` is
derived from `Fol` and only differs in way how it is visualized
on stereographic projection.

To create instance of `Lin`, `Fol` or `Pole` class, we have to provide
dip direction and dip, both in degrees:

<<term = True>>=
Lin(120,60)
Fol(216,62)
Pole(216,62)
@

or we can create instance from `Vec3` object:

<<term = True>>=
u.aslin
u.asfol
u.aspole
@

Vec3 methods for Lin, Fol and Pole
----------------------------------

To find angle between two linear or planar features:

<<term = True>>=
l1 = Lin(110,40)
l2 = Lin(160,30)
l1.angle(l2)
p1 = Fol(330,50)
p2 = Fol(250,40)
p1.angle(p2)
@

To construct planar feature defined by two linear features:

<<term = True>>=
l1**l2
@

To construct linear feature defined as intersection of two planar features:

<<term = True>>=
p1**p2
@

**Cross product** of planar and linear features could be used to:

- construct plane defined by linear feature and normal
  of planar feature:

<<term = True>>=
l2**p2
@

- or to find perpendicular linear feature on given plane.

<<term = True>>=
p2**l2
@

To rotate structural features we can use method `rotate`:

<<term = True>>=
p2.rotate(l2,45)
@

Group class
===========

`Group` class serve as a homogeneous container for `Lin`, `Fol` or `Pole`
objects. It allows grouping of features either for visualization or batch analysis.

<<term = True>>=
d = Group([Lin(120,60), Lin(116,50), Lin(132,45),
           Lin(90,60), Lin(84,52)], name='L1')
print(d)
@

Method `len` returns number of features in group:

<<term = True>>=
len(d)
@

Property `resultant` gives mean or resultant of all features in group:

<<term = True>>=
d.resultant
@

To measure angles between all features in group and another feature,
we can use method `angle`:

<<term = True>>=
d.angle(d.resultant)
@

To rotate all features in group around another feature,
we can use method `rotate`:

<<term = True>>=
d.rotate(Lin(150, 30), 45)
@

To calculate orientation tensor of all features in group,
we can use method `ortensor`:

<<term = True>>=
d.ortensor
@


Ortensor class
==============

`Ortensor` class represents orientation tensor of set of planar
or linear features. Eigenvalues and eigenvectors could be obtained
by methods `eigenvals` and `eigenvects`. Eigenvectors could be also
represented by linear or planar features using properties eigenlins
and eigenfols.

<<term = True>>=
ot = Ortensor(d)
ot.eigenvals
ot.eigenvects
ot.eigenlins
ot.eigenfols
@

Density class
=============

`Density` class represents Gaussian point density distribution of 
features from dataset. Parameters of calculation could be defined
by parameter `k` and by amount of counting points `npoints`. Number
of countours and color map could be modified by `nc` and `cm` properties.

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
c = Density(d, npoints=90)
c
c.plotcountgrid()
@

Schmidt projection
==================

Any `Fol`, `Lin`, `Pole`, `Vec3` or `Group` object could
be visualized in Schmidt projection:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
SchmidtNet(Fol(214,55), Lin(120,60), Pole(240,60), Vec3([-1,-2,1]))
@

Features could be added to Schmidt projection programatically as well:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
s = SchmidtNet()
s.add(Fol(150,40))
s.add(Pole(150,40))
s.add(Lin(112,30))
s.show()
@

`Dataset` properties as color and name are used during visualization:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
s.clear()
d = Group([Lin(120,60), Lin(116,50), Lin(132,45), Lin(95,52)], name='Test')
s.add(d)
s.add(d.ortensor)
s.show()
@

All mentioned classes could be freely combined:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
s.clear()
d = Group([Lin(120,70), Lin(116,42), Lin(132,45),
             Lin(95,52), Lin(114,48), Lin(118,58) ],
             name='G1', color='red')
s.add(d)
s.add(d.resultant)
s.add(*d.ortensor.eigenfols)
c = Density(d, nc=8)
s.add(c)
s.show()
@

Some tricks
-----------

Double cross product is allowed:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
s.clear()
p = Fol(250,40)
l = Lin(160,30)
s.add(p,l)
s.add(l**p,p**l)
s.add(l**p**l,p**l**p)
s.show()
@

Correct measurements of planar linear pairs:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
p1, l1 = fixpair(p,l)
s.clear()
s.add(p,l)
s.add(p1,l1)
s.show()
@
