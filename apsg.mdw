% Structural geology module for Python
% Ondrej Lexa <lexa.ondrej@gmail.com>
% 2014

Download and install APSG module
--------------------------------

APSG is distributed as a single file with no traditional python install
implemented yet. For now, download `apsg.py` file and save it to
working directory or to any folder on `PYTHONPATH`.

First steps with APSG module
============================

APSG defines several new python classes to easily manage, analyze
and visualize orientational structural geology data. Base class `Vec3`
is derived from `numpy.array` class and affers several new method
which will be explained on following examples.

Import APSG module
------------------

APSG module could be imported either into own namespace or into
active one for easier interactive work:

<<term = True>>=
from apsg import *
@

Basic operations with vectors
----------------------------

Instance of vector object `Vec3` could be created from any iterable
object as list, tuple or array:

<<term = True>>=
u = Vec3([1, -2, 3])
v = Vec3([-2, 1, 1])
@

For common vector operation we can use standard mathematical operators
or special methods using dot notation:

<<term = True>>=
u+v
u-v
3*u-2*v
@

Its magnitude or length is most commonly defined as its Euclidean norm
and could be calculated using `abs`:

<<term = True>>=
abs(v)
abs(u)
abs(2*u)
@

For *dot product* we can use multiplification operator `*`
or `dot` method:

<<term = True>>=
u*v
u.dot(v)
@

For *cross product* we can use operator `**` or method `cross`:

<<term = True>>=
u**v
u.cross(v)
@

To project vector `u` onto vector `v` we can use
method `proj`:

<<term = True>>=
u.proj(v)
@

To find angle (in degrees) between to vectors we use method `angle`:

<<term = True>>=
u.angle(v)
@

Method `rotate` provide possibility to rotate vector around
another vector. For example, to rotate vector `u` around
vector `v` for 45Â°:

<<term = True>>=
u.rotate(v,45)
@

Classes Fol a Lin
=================

To work with orientational data in structural geology, APSG
provide two classes derived from `Vec3` class. There is `Fol`
class to represent planar features by planes and `Lin` class
to represent linear feature by lines. Both classes provide all
`Vec3` methods, but they differ in way how instance is created
and how some operations are calculated, as structural geology
data are commonly axial in nature. The special class `Pole` is
derived from `Fol` and only differs in way how it is visualized
on stereographic projection.

To create instance of `Fol` or `Lin` class, we have to provide
dip direction and dip, both in degrees:

<<term = True>>=
Lin(120,60)
Fol(216,62)
Pole(216,62)
@

or we can create instance from `Vec3` object:

<<term = True>>=
u.aslin()
u.asfol()
u.aspole()
@

Vec3 methods for Fol a Lin
--------------------------

To find angle between two linear or planar features:

<<term = True>>=
l1 = Lin(110,40)
l2 = Lin(160,30)
l1.angle(l2)
p1 = Fol(330,50)
p2 = Fol(250,40)
p1.angle(p2)
@

To construct planar feature defined by two linear features:

<<term = True>>=
l1**l2
@

To construct linear feature defined as intersection of two planar features:

<<term = True>>=
p1**p2
@

**Cross product** of planar and linear features could be used to:

- construct plane defined by linear feature and normal
  of planar feature:

<<term = True>>=
l2**p2
@

- or to find perpendicular linear feature on given plane.

<<term = True>>=
p2**l2
@

Combined **cross product** could be used to find perpendicular
projection of linear feature onto planar one, or project planar
feature to pass trough linear feature:

<<term = True>>=
p2**l2**p2
l2**p2**l2
@

To rotate structural features we can use method `rotate`:

<<term = True>>=
p2.rotate(l2,45)
@

Dataset class
=============

`Dataset` class serve as list or container of `Fol` or `Lin` objects. It allows
grouping of features either for visualization or batch analysis.

<<term = True>>=
d = Dataset(name='Test data')
for dd in [Lin(120,60), Lin(116,50), Lin(132,45), Fol(90,60), Fol(84,52)]:
    d.append(dd)
print(d)
@

Same dataset could be created in simple way as:

<<term = True>>=
d = Dataset([Lin(120,60), Lin(116,50), Lin(132,45),
             Fol(90,60), Fol(84,52)], name='Test data')
print(d)
@

Method `len` returns number of features in dataset:

<<term = True>>=
len(d)
@

To select only linear or planar features we can use methods
`getlins` a `getfols`. Properties `numlin` a `numfol` gives
number of linear or planar features in dataset.

<<term = True>>=
d.getlins()
d.numlins
d.getfols()
d.numfols
@

Another property of dataset is `resultant`,which returns
mean or resultant of all features in dataset:

<<term = True>>=
d.getlins().resultant
d.getfols().resultant
@

To measure angles between all features in dataset and another feature,
we can use method `angle`:

<<term = True>>=
d = Dataset([Lin(120,60), Lin(116,50), Lin(132,45), Lin(95,52)])
d.angle(d.resultant)
@

To rotate all features in dataset around another feature,
we can use method `rotate`:

<<term = True>>=
d.rotate(l1, 45)
@

Ortensor class
==============

`Ortensor` class represents orientation tensor of set of planar
or linear features. Eigenvalues and eigenvectors could be obtained
by methods `eigenvals` and `eigenvects`. Eigenvectors could be also
represented by linear or planar features using properties eigenlins
and eigenfols.

<<term = True>>=
ot = Ortensor(d)
ot.eigenvals()
ot.eigenvects()
ot.eigenlins
ot.eigenfols
@

Density class
=============

`Density` class represents Gaussian point density distribution of 
features from dataset. Parameters of calculation could be defined
by parameter `k` and by amount of counting points `npoints`. Number
of countours and color map could be modified by `nc` and `cm` properties.

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
c = Density(d, npoints=90)
c
c.plotcountgrid()
@

Schmidt projection
==================

Any `Fol`, `Lin`, `Pole`, `Vec3' or `Dataset` object could
be visualized in Schmidt projection:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
SchmidtNet(Fol(214,55), Lin(120,60), Pole(240,60), Vec3([-1,-2,1]))
@

Features could be added to Schmidt projection programatically as well:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
s = SchmidtNet()
s.add(Fol(150,40))
s.add(Pole(150,40))
s.add(Lin(112,30))
s.show()
@

`Dataset` properties as color and name are used during visualization:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
s.clear()
d = Dataset([Lin(120,60), Lin(116,50), Lin(132,45), Lin(95,52)], name='Test')
s.add(d)
s.add(d.ortensor)
s.show()
@

All mentioned classes could be freely combined:

<<term = True, fig = True, width = '8cm', f_pos = "h!">>=
s.clear()
d = Dataset([Lin(120,70), Lin(116,42), Lin(132,45),
             Lin(95,52), Lin(114,48), Lin(118,58) ],
            color='red', name='Test data')
s.add(d)
s.add(d.resultant)
s.add(*d.ortensor.eigenfols)
c = Density(d, nc=8)
s.add(c)
s.show()
@

